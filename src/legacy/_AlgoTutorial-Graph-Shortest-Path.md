Timestamp: 20221123 未完成    
Todo: 
* Bellman-Ford, Floyd 算法的分析，时间空间复杂度分析。 
* 学习算法第四版4.4 完成 认真的最短路径问题。

# 最短路径算法专题 急功近利的
具体算法的实现我们具体的写。
我们这里high-level的讨论一下。   

## 最短路径的应用
在计算机网络中，有一个很重要的东西就是路由，即一个包怎么从某个节点发送到另外一个节点，在多条路径可供选择的时候，怎么选出来最佳路径，可以说，最短路算法是计算机网络的基石之一。
其他的常见应用，有地图导航，任务调度，套汇等等。

## 最短路径的算法
急功近利看这里：
> 面试来说，时间如果很紧急，只需要看 Dijkstra 算法。       

最短路径问题，首先是一个图的问题，因此需要讨论什么算法适用什么图。

* Dijkstra算法只适用于没有负权边的图，可以适用于有向无向。
    * 之所以不能有负权边，是因为Dijkstra的思想是基于贪心。非负权边可以保证总的路径权重是一直在增加或保持不变的，负权边使得贪心法直接失效了。
* Bellman-Ford 算法适用于有负权边的图，但是也有其局限。


# 认真的最短路径问题
术语：
* 加权图：edge-weighted graph.
* 边权重：edge weight.
* 路径权重： path weight.
* 松弛：relaxing / relax. 
    * 松弛得名于橡皮筋从更长的路径变为更短的路径，从而更松了。


## 最短路径的基本数据结构配置
* 我们用一个 HashMap<Integer, Double> distTo 记录源点s到各个点的最短距离。
    * 源点到自己的距离初始化为0. 源点到其他点的距离初始化为Double.POSITIVE_INFINITY. 注意java中 Integer不支持infinity。
* 我们记录最短的路径是用一个 HashMap<Integer, Integer> edgeTo 来实现的。我们记录的key是当前的节点，value是它的从源到key的最短路径上的父节点。
    * 我们可以根据这个结构来反向推导出到任意点的最短路径。
    * 这是针对有向图限定的。

边的松弛 relaxing 是实现最短路径算法的基础。    
relax edge v -> w 意味着：
* 检查从 s 到 w 的最短路径是否是 s -> ... -> v -> w。
    * 如果是的话，那么更新 distTo 和 edgeTo. 这条边是有效边 eligible
    * 不是的话，这条边就失效了，ineligible.

所以，当我们在别处看到松弛 relax 的术语时，描述的就是这么一个过程。

 
